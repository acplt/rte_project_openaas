
/******************************************************************************
*
*   FILE
*   ----
*   MatchPVSRA.c
*
*   History
*   -------
*   2017-03-08   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_propertyValueStatement
#define OV_COMPILE_LIBRARY_propertyValueStatement
#endif


#include "propertyValueStatement.h"
#include "propertyValueStatement_helpers.h"
#include "libov/ov_macros.h"
#include "stdfb_comp_macros.h"
#include "libov/ov_path.h"


// if any1 > any2
OV_BOOL GreaterThan (const OV_ANY any1, const OV_ANY any2){
	if(!(any1.value.vartype & OV_VT_ISVECTOR)){
		switch(any1.value.vartype & OV_VT_KSMASK){
			STDFB_GT(BOOL, bool);
			STDFB_GT(BYTE, byte);
			STDFB_GT(UINT, uint);
			STDFB_GT(INT, int);
			STDFB_GT(SINGLE, single);
			STDFB_GT(DOUBLE, double);

			case OV_VT_TIME:
				if(STDFB_GT_TIME(any1.value.valueunion.val_time, any2.value.valueunion.val_time))
					return TRUE;
				else
					return FALSE;
			break;

			case OV_VT_TIME_SPAN:
				if(STDFB_GT_TIME(any1.value.valueunion.val_time_span, any2.value.valueunion.val_time_span))
					return TRUE;
				else
					return FALSE;
			break;

			default:
				ov_logfile_error("%s: comparison of given datatype not implementes");
				return FALSE;
		}
	}else{
		ov_logfile_error("%s: comparison of given datatype not implementes");
		return FALSE;
	}
}

// if any1 >= any2
OV_BOOL GreaterEqual (const OV_ANY any1, const OV_ANY any2){
	if(!(any1.value.vartype & OV_VT_ISVECTOR)){
		switch(any1.value.vartype & OV_VT_KSMASK){
			STDFB_GE(BOOL, bool);
			STDFB_GE(BYTE, byte);
			STDFB_GE(UINT, uint);
			STDFB_GE(INT, int);
			STDFB_GE(SINGLE, single);
			STDFB_GE(DOUBLE, double);

			case OV_VT_TIME:
				if(STDFB_GE_TIME(any1.value.valueunion.val_time, any2.value.valueunion.val_time))
					return TRUE;
				else
					return FALSE;
			break;

			case OV_VT_TIME_SPAN:
				if(STDFB_GE_TIME(any1.value.valueunion.val_time_span, any2.value.valueunion.val_time_span))
					return TRUE;
				else
					return FALSE;
			break;

			default:
				ov_logfile_error("%s: comparison of given datatype not implementes");
				return FALSE;
		}
	}else{
		ov_logfile_error("%s: comparison of given datatype not implementes");
		return FALSE;
	}
}

// if any1 == any2
OV_BOOL Equal (const OV_ANY any1, const OV_ANY any2){
	if(!(any1.value.vartype & OV_VT_ISVECTOR)){
		switch(any1.value.vartype & OV_VT_KSMASK){
			STDFB_EQ(BOOL, bool);
			STDFB_EQ(BYTE, byte);
			STDFB_EQ(UINT, uint);
			STDFB_EQ(INT, int);
			STDFB_EQ(SINGLE, single);
			STDFB_EQ(DOUBLE, double);

			case OV_VT_STRING:
				if(ov_string_compare(any1.value.valueunion.val_string, any2.value.valueunion.val_string) == 0)
					return TRUE;
				else
					return FALSE;
			break;

			case OV_VT_TIME:
				if(STDFB_EQ_TIME(any1.value.valueunion.val_time, any2.value.valueunion.val_time))
					return TRUE;
				else
					return FALSE;
			break;

			case OV_VT_TIME_SPAN:
				if(STDFB_EQ_TIME(any1.value.valueunion.val_time_span, any2.value.valueunion.val_time_span))
					return TRUE;
				else
					return FALSE;
			break;

			default:
				ov_logfile_error("%s: comparison of given datatype not implementes");
				return FALSE;
		}
	}else{
		ov_logfile_error("%s: comparison of given datatype not implementes");
		return FALSE;
	}
}

// if any1 != any2
OV_BOOL NotEqual (const OV_ANY any1, const OV_ANY any2){
	if(!(any1.value.vartype & OV_VT_ISVECTOR)){
		switch(any1.value.vartype & OV_VT_KSMASK){
			STDFB_NE(BOOL, bool);
			STDFB_NE(BYTE, byte);
			STDFB_NE(UINT, uint);
			STDFB_NE(INT, int);
			STDFB_NE(SINGLE, single);
			STDFB_NE(DOUBLE, double);

			case OV_VT_STRING:
				if(ov_string_compare(any1.value.valueunion.val_string, any2.value.valueunion.val_string) != 0)
					return TRUE;
				else
					return FALSE;
			break;

			case OV_VT_TIME:
				if(STDFB_NE_TIME(any1.value.valueunion.val_time, any2.value.valueunion.val_time))
					return TRUE;
				else
					return FALSE;
			break;

			case OV_VT_TIME_SPAN:
				if(STDFB_NE_TIME(any1.value.valueunion.val_time_span, any2.value.valueunion.val_time_span))
					return TRUE;
				else
					return FALSE;
			break;

			default:
				ov_logfile_error("%s: comparison of given datatype not implementes");
				return FALSE;
		}
	}else{
		ov_logfile_error("%s: comparison of given datatype not implementes");
		return FALSE;
	}
}

// if any1 <= any2
OV_BOOL LessEqual (const OV_ANY any1, const OV_ANY any2){
	if(!(any1.value.vartype & OV_VT_ISVECTOR)){
		switch(any1.value.vartype & OV_VT_KSMASK){
			STDFB_LE(BOOL, bool);
			STDFB_LE(BYTE, byte);
			STDFB_LE(UINT, uint);
			STDFB_LE(INT, int);
			STDFB_LE(SINGLE, single);
			STDFB_LE(DOUBLE, double);

			case OV_VT_TIME:
				if(STDFB_LE_TIME(any1.value.valueunion.val_time, any2.value.valueunion.val_time))
					return TRUE;
				else
					return FALSE;
			break;

			case OV_VT_TIME_SPAN:
				if(STDFB_LE_TIME(any1.value.valueunion.val_time_span, any2.value.valueunion.val_time_span))
					return TRUE;
				else
					return FALSE;
			break;

			default:
				ov_logfile_error("%s: comparison of given datatype not implementes");
				return FALSE;
		}
	}else{
		ov_logfile_error("%s: comparison of given datatype not implementes");
		return FALSE;
	}
}

// if any1 < any2
OV_BOOL LessThan (const OV_ANY any1, const OV_ANY any2){
	if(!(any1.value.vartype & OV_VT_ISVECTOR)){
		switch(any1.value.vartype & OV_VT_KSMASK){
			STDFB_LT(BOOL, bool);
			STDFB_LT(BYTE, byte);
			STDFB_LT(UINT, uint);
			STDFB_LT(INT, int);
			STDFB_LT(SINGLE, single);
			STDFB_LT(DOUBLE, double);

			case OV_VT_TIME:
				if(STDFB_LT_TIME(any1.value.valueunion.val_time, any2.value.valueunion.val_time))
					return TRUE;
				else
					return FALSE;
			break;

			case OV_VT_TIME_SPAN:
				if(STDFB_LT_TIME(any1.value.valueunion.val_time_span, any2.value.valueunion.val_time_span))
					return TRUE;
				else
					return FALSE;
			break;

			default:
				ov_logfile_error("%s: comparison of given datatype not implementes");
				return FALSE;
		}
	}else{
		ov_logfile_error("%s: comparison of given datatype not implementes");
		return FALSE;
	}
}



OV_DLLFNCEXPORT OV_UINT propertyValueStatement_MatchPVSRA_matchPVSRA(OV_STRING requirementPath, OV_STRING assurancePath, OV_BOOL *match, OV_STRING *matchText, OV_STRING *errorText) {
	OV_INSTPTR_propertyValueStatement_PropertyValueStatement requirement = NULL;
	OV_INSTPTR_propertyValueStatement_PropertyValueStatement assurance = NULL;
	OV_INSTPTR_ov_object pobj = NULL;
	OV_INSTPTR_ov_object pobj2 = NULL;
	pobj = ov_path_getobjectpointer(requirementPath, 2);
	if (!pobj){
		ov_string_setvalue(errorText, "requirementPath is not valid");
		return 1;
	}
	if (!Ov_CanCastTo(propertyValueStatement_PropertyValueStatement, pobj)){
		ov_string_setvalue(errorText, "requirementPath is not a path to an PropertyValueStatement");
		return 1;
	}

	pobj2 = ov_path_getobjectpointer(assurancePath, 2);
	if (!pobj2){
		ov_string_setvalue(errorText, "assurancePath is not valid");
		return 1;
	}
	if (!Ov_CanCastTo(propertyValueStatement_PropertyValueStatement, pobj2)){
		ov_string_setvalue(errorText, "assurancePath is not a path to an PropertyValueStatement");
		return 1;
	}

	requirement = Ov_DynamicPtrCast(propertyValueStatement_PropertyValueStatement, pobj);
	assurance = Ov_DynamicPtrCast(propertyValueStatement_PropertyValueStatement, pobj2);

	// check
	if (requirement->v_IDIdType != assurance->v_IDIdType){
		ov_string_print(matchText, "requirement %s and assurance %s IDTypes are not the same", requirement->v_identifier, assurance->v_identifier);
		return 0;
	}
	if (ov_string_compare(requirement->v_IDIdString, assurance->v_IDIdString) != OV_STRCMP_EQUAL){
		ov_string_print(matchText, "requirement %s and assurance %s IDs are not the same", requirement->v_identifier, assurance->v_identifier);
		return 0;
	}
	if(ov_string_compare(requirement->v_Unit, assurance->v_Unit) != OV_STRCMP_EQUAL){
		ov_string_print(matchText, "requirement %s and assurance %s Units are not the same", requirement->v_identifier, assurance->v_identifier);
		return 0;
	}
	if (requirement->v_Value.value.vartype != assurance->v_Value.value.vartype){
		ov_string_print(matchText, "requirement %s and assurance %s have not the same datatype", requirement->v_identifier, assurance->v_identifier);
		return 0;
	}

	switch(requirement->v_ExpressionLogic){
	case GREATER_THAN:
		switch(assurance->v_ExpressionLogic){
			case GREATER_THAN:
				*match = GreaterThan(assurance->v_Value, requirement->v_Value);
				break;
			case GREATER_EQUAL:
				*match = GreaterThan(assurance->v_Value, requirement->v_Value);
				break;
			case EQUAL:
				*match = GreaterThan(assurance->v_Value, requirement->v_Value);
				break;
			case NOT_EQUAL:
				*match = 0;
				break;
			case LESS_EQUAL:
				*match = 0;
				break;
			case LESS_THAN:
				*match = 0;
				break;
			default:
				ov_string_print(errorText, "unknown expression logic from assurance %s", assurance->v_identifier);
				return 1;
				break;
			}
		break;
	case GREATER_EQUAL:
		switch(assurance->v_ExpressionLogic){
			case GREATER_THAN:
				*match = GreaterEqual(assurance->v_Value, requirement->v_Value);
				break;
			case GREATER_EQUAL:
				*match = GreaterEqual(assurance->v_Value, requirement->v_Value);
				break;
			case EQUAL:
				*match = GreaterEqual(assurance->v_Value, requirement->v_Value);
				break;
			case NOT_EQUAL:
				*match = 0;
				break;
			case LESS_EQUAL:
				*match = 0;
				break;
			case LESS_THAN:
				*match = 0;
				break;
			default:
				ov_string_print(errorText, "unknown expression logic from assurance %s", assurance->v_identifier);
				return 1;
				break;
			}
		break;
	case EQUAL:
		switch(assurance->v_ExpressionLogic){
			case GREATER_THAN:
				*match = 0;
				break;
			case GREATER_EQUAL:
				*match = 0;
				break;
			case EQUAL:
				*match = Equal(assurance->v_Value, requirement->v_Value);
				break;
			case NOT_EQUAL:
				*match = 0;
				break;
			case LESS_EQUAL:
				*match = 0;
				break;
			case LESS_THAN:
				*match = 0;
				break;
			default:
				ov_string_print(errorText, "unknown expression logic from assurance %s", assurance->v_identifier);
				return 1;
				break;
			}
		break;
	case NOT_EQUAL:
		switch(assurance->v_ExpressionLogic){
			case GREATER_THAN:
				*match = GreaterThan(assurance->v_Value, requirement->v_Value);
				break;
			case GREATER_EQUAL:
				*match = GreaterThan(assurance->v_Value, requirement->v_Value);
				break;
			case EQUAL:
				*match = NotEqual(assurance->v_Value, requirement->v_Value);
				break;
			case NOT_EQUAL:
				*match = Equal(assurance->v_Value, requirement->v_Value);
				break;
			case LESS_EQUAL:
				*match = LessThan(assurance->v_Value, requirement->v_Value);
				break;
			case LESS_THAN:
				*match = LessThan(assurance->v_Value, requirement->v_Value);
				break;
			default:
				ov_string_print(errorText, "unknown expression logic from assurance %s", assurance->v_identifier);
				return 1;
				break;
			}
		break;
	case LESS_EQUAL:
		switch(assurance->v_ExpressionLogic){
			case GREATER_THAN:
				*match = 0;
				break;
			case GREATER_EQUAL:
				*match = 0;
				break;
			case EQUAL:
				*match = LessEqual(assurance->v_Value, requirement->v_Value);
				break;
			case NOT_EQUAL:
				*match = 0;
				break;
			case LESS_EQUAL:
				*match = LessEqual(assurance->v_Value, requirement->v_Value);
				break;
			case LESS_THAN:
				*match = LessEqual(assurance->v_Value, requirement->v_Value);
				break;
			default:
				ov_string_print(errorText, "unknown expression logic from assurance %s", assurance->v_identifier);
				return 1;
				break;
			}
		break;
	case LESS_THAN:
		switch(assurance->v_ExpressionLogic){
			case GREATER_THAN:
				*match = 0;
				break;
			case GREATER_EQUAL:
				*match = 0;
				break;
			case EQUAL:
				*match = LessThan(assurance->v_Value, requirement->v_Value);
				break;
			case NOT_EQUAL:
				*match = 0;
				break;
			case LESS_EQUAL:
				*match = LessThan(assurance->v_Value, requirement->v_Value);
				break;
			case LESS_THAN:
				*match = LessThan(assurance->v_Value, requirement->v_Value);
				break;
			default:
				ov_string_print(errorText, "unknown expression logic from assurance %s", assurance->v_identifier);
				return 1;
				break;
			}
		break;
	default:
		ov_string_print(errorText, "unknown expression logic from requirement %s", requirement->v_identifier);
		return 1;
		break;
	}
    return (OV_UINT)0;
}


OV_DLLFNCEXPORT void propertyValueStatement_MatchPVSRA_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*
    *   local variables
    */
    OV_INSTPTR_propertyValueStatement_MatchPVSRA pinst = Ov_StaticPtrCast(propertyValueStatement_MatchPVSRA, pfb);
    pinst->v_error = 0;
    ov_string_setvalue(&pinst->v_errortext, "");
	pinst->v_match = FALSE;

	// Get Object pointer
	pinst->v_error = propertyValueStatement_MatchPVSRA_matchPVSRA(pinst->v_requirementPath, pinst->v_assurancePath, &pinst->v_match, &pinst->v_matchText, &pinst->v_errortext);

    return;
}

