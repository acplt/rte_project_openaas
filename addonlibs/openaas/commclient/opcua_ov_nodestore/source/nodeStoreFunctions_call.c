
/******************************************************************************
 *
 *   FILE
 *   ----
 *   nodeStoreFunctions.c
 *
 *   History
 *   -------
 *   2014-10-21   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_opcua
#define OV_COMPILE_LIBRARY_opcua
#endif



#include "libov/ov_macros.h"
#include "ksbase.h"
#include "opcua.h"
#include "opcua_helpers.h"
#include "NoneTicketAuthenticator.h"
#include "ks_logfile.h"
#include "libov/ov_path.h"
#include "libov/ov_memstack.h"

extern OV_INSTPTR_opcua_uaServer opcua_pUaServer;

OV_DLLFNCEXPORT OV_RESULT opcua_nodeStoreFunctions_packCallArgs(
	OV_UINT	numberofArgs,
	const OV_ANY *argList,
	UA_Variant **packedArgList
) {
	OV_UINT iterator = 0;
	UA_StatusCode result;
	if(*packedArgList == UA_EMPTY_ARRAY_SENTINEL){
    	return OV_ERR_OK;
    }
    for(iterator = 0; iterator < numberofArgs; iterator++){
    	result = ov_AnyToVariant(&(argList[iterator]), &((*packedArgList)[iterator]));
    	if(result != UA_STATUSCODE_GOOD){
    		UA_Array_delete(*packedArgList, numberofArgs, &UA_TYPES[UA_TYPES_VARIANT]);
    		if(result == UA_STATUSCODE_BADOUTOFMEMORY)
    			return OV_ERR_HEAPOUTOFMEMORY;
    		else
    			return OV_ERR_GENERIC;
    	}
    }
	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT opcua_nodeStoreFunctions_unpackCallArgs(
	OV_UINT numberofArgs,
	const UA_Variant *packedArgList,
	OV_ANY	*argList
) {
	OV_UINT iterator = 0;
	UA_StatusCode result;

	if(!numberofArgs){
		argList = NULL;
		return OV_ERR_OK;
	}

	for(iterator = 0; iterator < numberofArgs; iterator++){
		result = ov_VariantToAny(&(packedArgList[iterator]), &(argList[iterator]));
		if(result != UA_STATUSCODE_GOOD){
			if(result == UA_STATUSCODE_BADOUTOFMEMORY)
				return OV_ERR_HEAPOUTOFMEMORY;
			else
				return OV_ERR_GENERIC;
		}
	}
	return OV_ERR_OK;
}

OV_DLLFNCEXPORT UA_StatusCode opcua_nodeStoreFunctions_getCallArgs(
	OV_INSTPTR_opcua_arguments pobj,
	OV_UINT	*numberofArgs,
	UA_Argument	**argList
) {
	OV_UINT iterator = 0;
	if(!numberofArgs || !argList){
		return UA_STATUSCODE_BADINVALIDARGUMENT;
	}
	if(pobj->v_Names.veclen != pobj->v_Types.veclen || pobj->v_Names.veclen != pobj->v_isArray.veclen
			|| pobj->v_Names.veclen != pobj->v_Lengths.veclen || pobj->v_Names.veclen != pobj->v_Descriptions.veclen){
		return UA_STATUSCODE_BADNODEATTRIBUTESINVALID;
	}
	*numberofArgs = pobj->v_Names.veclen;
	*argList = UA_Array_new(*numberofArgs, &UA_TYPES[UA_TYPES_ARGUMENT]);
	if(!*argList){
		return UA_STATUSCODE_BADOUTOFMEMORY;
	}
	/*	iterate over all argument descriptions	*/
	for(iterator = 0; iterator < *numberofArgs; iterator++){
		/*	name	*/
		(*argList)[iterator].name = UA_String_fromChars(pobj->v_Names.value[iterator]);
		if(!(*argList)[iterator].name.data){
			return UA_STATUSCODE_BADOUTOFMEMORY;
		}
		/*	dataType	*/
		(*argList)[iterator].dataType = ov_varTypeToNodeId(pobj->v_Types.value[iterator]);
		/*	ValueRank and Array Dimensions	*/
		if(pobj->v_isArray.value[iterator]){
			(*argList)[iterator].valueRank = 1;
			(*argList)[iterator].arrayDimensionsSize = 1;
			(*argList)[iterator].arrayDimensions = UA_Array_new(1, &UA_TYPES[UA_TYPES_UINT32]);
			if(!(*argList)[iterator].arrayDimensions){
				return UA_STATUSCODE_BADOUTOFMEMORY;
			}
			(*argList)[iterator].arrayDimensions[0] = pobj->v_Lengths.value[iterator];
		} else {
			(*argList)[iterator].valueRank = -1;
			(*argList)[iterator].arrayDimensionsSize = 0;
		}
		/*	description	*/
		(*argList)[iterator].description.locale = UA_String_fromChars("en");
		if(!(*argList)[iterator].description.locale.data){
			return UA_STATUSCODE_BADOUTOFMEMORY;
		}
		(*argList)[iterator].description.text = UA_String_fromChars(pobj->v_Descriptions.value[iterator]);
		if(!(*argList)[iterator].description.text.data){
			return UA_STATUSCODE_BADOUTOFMEMORY;
		}
	}
	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT opcua_nodeStoreFunctions_setCallArgs(
	OV_INSTPTR_opcua_arguments pobj,
	OV_UINT	numberofArgs,
	OV_STRING* names,
    OV_STRING* descriptions,
    OV_INT* types,
    OV_BOOL* isArray,
    OV_UINT* lengths
) {
	OV_RESULT result;

	result = Ov_SetDynamicVectorValue(&(pobj->v_Names), names, numberofArgs, STRING);
	if(Ov_Fail(result)){
		return result;
	}
	result = Ov_SetDynamicVectorValue(&(pobj->v_Descriptions), descriptions, numberofArgs, STRING);
	if(Ov_Fail(result)){
		return result;
	}
	result = Ov_SetDynamicVectorValue(&(pobj->v_Types), types, numberofArgs, INT);
	if(Ov_Fail(result)){
		return result;
	}
	result = Ov_SetDynamicVectorValue(&(pobj->v_Lengths), lengths, numberofArgs, UINT);
	if(Ov_Fail(result)){
		return result;
	}
	result = Ov_SetDynamicVectorValue(&(pobj->v_isArray), isArray, numberofArgs, BOOL);
	if(Ov_Fail(result)){
		return result;
	}
	return OV_ERR_OK;
}


/*	copied from stack and deleted a lot of things we do not need in ov	*/
static UA_StatusCode
satisfySignature(const UA_Variant *var, const UA_Argument *arg) {
    if(!UA_NodeId_equal(&var->type->typeId, &arg->dataType)){
        return UA_STATUSCODE_BADINVALIDARGUMENT;
    }

    // Note: The namespace compiler will compile nodes with their actual array dimensions
    // Todo: Check if this is standard conform for scalars
    if(arg->arrayDimensionsSize > 0 && var->arrayDimensionsSize > 0)
        if(var->arrayDimensionsSize > 1)
            return UA_STATUSCODE_BADINVALIDARGUMENT;

   /* ValueRank Semantics
     *  n >= 1: the value is an array with the specified number of dimens*ions.
     *  n = 0: the value is an array with one or more dimensions.
     *  n = -1: the value is a scalar.
     *  n = -2: the value can be a scalar or an array with any number of dimensions.
     *  n = -3:  the value can be a scalar or a one dimensional array.
     *  in OV we only have 1 and -1	*/
    switch(arg->valueRank) {
    case -1:
        if(!(var->arrayLength == 0 && var->data > UA_EMPTY_ARRAY_SENTINEL))
            return UA_STATUSCODE_BADINVALIDARGUMENT;
        break;
    case 1:
    	if(var->arrayDimensionsSize > 1)
    		return UA_STATUSCODE_BADINVALIDARGUMENT;
        break;
    default:
    	KS_logfile_error(("call-satisfySignature: weird valueRank."));
    	return UA_STATUSCODE_BADINTERNALERROR;
        break;
    }

    return UA_STATUSCODE_GOOD;
}


OV_DLLFNCEXPORT UA_Int32 opcua_nodeStoreFunctions_call(
	void *ensHandle,
	const UA_RequestHeader *requestHeader,
	UA_CallMethodRequest *request,
	UA_UInt32 *indices,
	UA_UInt32 indicesSize,
	UA_CallMethodResult *results
) {

	//OV_UINT nsIndex = opcua_pUaServer->v_NameSpaceIndex;
	OV_PATH path;
	OV_INSTPTR_opcua_methodNode pMethodNode = NULL;
	OV_VTBLPTR_opcua_methodNode pVtblMethodNode = NULL;
	OV_INSTPTR_ov_object pParentObject = NULL;
	OV_INSTPTR_opcua_arguments pArgObject	=	NULL;
	UA_Argument* pArgs = NULL;
	size_t argCount = 0;


	KS_logfile_debug(("UA-Call requested in OV-Namespace."));
	for(OV_UINT i = 0; i<indicesSize;i++){
		/*	find and verify method	*/
		ov_memstack_lock();
		results[indices[i]].statusCode = opcua_nodeStoreFunctions_resolveNodeIdToPath(request[indices[i]].methodId, &path);
		if(results[indices[i]].statusCode != UA_STATUSCODE_GOOD){
			ov_memstack_unlock();
			continue;
		}
		if(!path.elements[path.size-1].pobj){
			results[indices[i]].statusCode = UA_STATUSCODE_BADMETHODINVALID;
			ov_memstack_unlock();
			continue;
		}
		pMethodNode = Ov_DynamicPtrCast(opcua_methodNode, path.elements[path.size-1].pobj);
		if(!pMethodNode){
			results[indices[i]].statusCode = UA_STATUSCODE_BADNODECLASSINVALID;
			ov_memstack_unlock();
			continue;
		}
		if(!pMethodNode->v_callable){
			results[indices[i]].statusCode = UA_STATUSCODE_BADNOTWRITABLE;
			ov_memstack_unlock();
			continue;
		}
		/*	find and verify parent node	*/
		results[indices[i]].statusCode = opcua_nodeStoreFunctions_resolveNodeIdToPath(request[indices[i]].objectId, &path);
		if(results[indices[i]].statusCode != UA_STATUSCODE_GOOD){
			ov_memstack_unlock();
			continue;
		}
		if(!path.elements[path.size-1].pobj){
			results[indices[i]].statusCode = UA_STATUSCODE_BADNODEIDINVALID;
			ov_memstack_unlock();
			continue;
		}
		pParentObject = path.elements[path.size-1].pobj;
		if(opcua_nsOv_getNodeClassAndAccess(&(path.elements[path.size-1]), NULL) != UA_NODECLASS_OBJECT){
			results[indices[i]].statusCode = UA_STATUSCODE_BADNODECLASSINVALID;
			ov_memstack_unlock();
			continue;
		}
		/*	call preCallMethod to determine node status	*/
		Ov_GetVTablePtr(opcua_methodNode, pVtblMethodNode, pMethodNode);
		if(!pVtblMethodNode){
			results[indices[i]].statusCode = UA_STATUSCODE_BADINTERNALERROR;
			ov_memstack_unlock();
			continue;
		}
		results[indices[i]].statusCode = pVtblMethodNode->m_preCallMethod(pMethodNode);
		if(results[indices[i]].statusCode != UA_STATUSCODE_GOOD){
			ov_memstack_unlock();
			continue;
		}
		/*	verify arguments	*/
		pArgObject = &(pMethodNode->p_InputArguments);
		results[indices[i]].statusCode = opcua_nodeStoreFunctions_getCallArgs(pArgObject, &argCount, &pArgs);
		if(results[indices[i]].statusCode != UA_STATUSCODE_GOOD){
			ov_memstack_unlock();
			continue;
		}
		if(argCount != request[indices[i]].inputArgumentsSize){
			if(argCount > request[indices[i]].inputArgumentsSize){
				results[indices[i]].statusCode = UA_STATUSCODE_BADARGUMENTSMISSING;
			}else {
				results[indices[i]].statusCode = UA_STATUSCODE_BADINVALIDARGUMENT;
			}
			ov_memstack_unlock();
			continue;
		}
		for(OV_UINT j = 0; j < argCount; j++){
			results[indices[i]].statusCode = satisfySignature(&(request[indices[i]].inputArguments[j]), &(pArgs[j]));
			if(results[indices[i]].statusCode != UA_STATUSCODE_GOOD){
				KS_logfile_info(("Call: mismatch in Argument %u for method %s", j, pMethodNode->v_identifier));
				ov_memstack_unlock();
				continue;
			}
		}
		/*	create array for response. use the length of the names vector to determine argument count	*/
		results[indices[i]].outputArguments = UA_Array_new(pMethodNode->p_OutputArguments.v_Names.veclen, &UA_TYPES[UA_TYPES_VARIANT]);
		if(!results[indices[i]].outputArguments) {
			results[indices[i]].statusCode = UA_STATUSCODE_BADOUTOFMEMORY;
			ov_memstack_unlock();
			continue;
		}
		results[indices[i]].outputArgumentsSize = pMethodNode->p_OutputArguments.v_Names.veclen;

		/*	issue the real call	*/
		results[indices[i]].statusCode = ov_resultToUaStatusCode(pVtblMethodNode->m_calledMethod(pMethodNode, request[indices[i]].inputArgumentsSize, request[indices[i]].inputArguments,
				results[indices[i]].outputArgumentsSize, &(results[indices[i]].outputArguments)));
		if(results[indices[i]].statusCode != UA_STATUSCODE_GOOD){
			pVtblMethodNode->m_postCallMethod(pMethodNode, TRUE);
			ov_memstack_unlock();
			continue;
		} else {
			pVtblMethodNode->m_postCallMethod(pMethodNode, FALSE);
		}

		ov_memstack_unlock();
	}
	return UA_STATUSCODE_GOOD;
}

